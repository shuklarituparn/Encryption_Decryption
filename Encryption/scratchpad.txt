To get the MSB simply do the binary and with the number you want to get the MSB with a number in which the
all the MSB are set as 1

Num & 0xFFFF0000

To get the LSB simply do the binary and with the number you want to get the LSB with a number in which the
all the LSB are set as 1

Num & 0x0000FFFF

this will leave the LSB intact

data[:b_message_lenght] = (data[:b_message_lenght] & ~1) | b_message

//This taking the AND with the complement of A will make the LSB free and then taking the OR will fill the place

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import sys
import math
from os import path

import cv2
import numpy as np


BITS = 2   #using the bucket of two bits

HIGH_BITS = 256 - (1 << BITS) #clearing the least significant bits
LOW_BITS = (1 << BITS) - 1   #
BYTES_PER_BYTE = math.ceil(8 / BITS)
FLAG = '%'


def insert(img_path, msg):
    img = cv2.imread(img_path, cv2.IMREAD_ANYCOLOR)
    # Save origin shape to restore image
    ori_shape = img.shape
    print(ori_shape)
    max_bytes = ori_shape[0] * ori_shape[1] // BYTES_PER_BYTE
    # Encode message with length
    msg = '{}{}{}'.format(len(msg), FLAG, msg)
    assert max_bytes >= len(
        msg), "Message greater than capacity:{}".format(max_bytes)
    data = np.reshape(img, -1)
    for (idx, val) in enumerate(msg):
        encode(data[idx * BYTES_PER_BYTE: (idx + 1) * BYTES_PER_BYTE], val)

    img = np.reshape(data, ori_shape)
    filename, _ = path.splitext(img_path)
    filename += '_lsb_embeded' + ".png"
    cv2.imwrite(filename, img)
    return filename


def encode(block, data):
    # returns the Unicode code from a given character
    data = ord(data)
    for idx in range(len(block)):
        block[idx] &= HIGH_BITS
        block[idx] |= (data >> (BITS * idx)) & LOW_BITS

def decrypt():
    pass



if __name__ == '__main__':

    if len(sys.argv) == 3:
        img_path = sys.argv[1]
        msg = sys.argv[2]
    else:
        img_path = "img.jpg"
        msg = 'We got our man. Leave from the shipping port, gate B by Friday evening.'

    res_path = insert(img_path, msg)
    print("Successfully embedded.")






///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



message_to_code = 'hello'

# Encoding the text in the 8bit values

# Encoding the text in the 8bit values
b_message = ''.join(["{:08b}".format(ord(x)) for x in message_to_code])
b_message = [int(x, 2) for x in b_message]  # converting the ascii to the binary

b_message_length = len(b_message)

# opening the image
with Image.open('img.png') as img:
    width, height = img.size
    data = np.array(img)

# flattening the image into one single array

data = np.reshape(data, ( height, width, 3))

# encoding the data

# Encoding the data
for i in range(b_message_length):
    data[i % height, i % width, i % 3] = (data[i % height, i % width, i % 3] & ~1) | b_message[i]


# reshaping the file

data = np.reshape(data, (height,width,3))

new_image= Image.fromarray(data)
new_image.save(input("Enter the name of the output file")+'.png')
new_image.show()



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if __name__ == "__main__":
    input_string = input("Enter the string you want to encrypt: ")
    vig1 = VernamCipher(input_string)
    key_string = input("Enter the key string ")
    print(VernamCipher.vernam_decrypt(input_string, key_string))
#AABQROQUOK

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Usage example:
text_path = "vigenere_text.txt"
key_path = "vigenere_key.txt"

text = VigenereCipher.read_text_from_file(text_path)
key = VigenereCipher.read_key_from_file(key_path)

vigenere_cipher = VigenereCipher(text)
encrypted_text = vigenere_cipher.vigenere_encrypt(text, key)

decrypted_text = vigenere_cipher.vigenere_decrypt(encrypted_text, key)
print("The original text is: ", text)
print("The key is: ", key)

print("Encrypted Text:", encrypted_text)
print("Decrypted Text:", decrypted_text)

#GCYCZFMLYLEIM

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
if __name__ == "__main__":
    while True:
        print(f'\n{"-" * 10}\n Menu\n{"-" * 10}')
        print(*["1.Encrypt", "2.Decrypt", "3.Quit"], sep="\n")

        choice = input("\nWhat would you like to do?: ").strip() or "5"

        if choice not in ("1", "2", "3"):
            print("Invalid choice, please enter a valid choice")
        elif choice == "1":
            os.system('clear')
            print(f'\n{"-" * 10}\nChoose the Encryption Method:\n{"-" * 10}')
            print(*["1.Caesar", "2.Vigenere", "3.Vernam"], sep="\n")
            type_encryption = input().strip()
            if type_encryption not in ("1", "2", "3"):
                print("Invalid choice, please enter a valid choice")
            elif type_encryption == '1':
                os.system('clear')
                print("Encrypting using the Caesar Cipher: \n")
                print("Enter the string you want to encrypt: ")
                input_string = input().strip()
                key = int(input("Please enter off-set: ").strip())
                print(encrypt(input_string, key))

            elif type_encryption == '2':
                os.system("cls")
                print("Encrypting using the Vigenere Cipher: \n")
                print("Enter the string you want to encrypt: ")
                input_string = input().strip()
                print("Enter the key you want to encrypt with: ")
                key_string = input().strip()
                print(vigenere_encrypt(input_string, key_string))


            elif type_encryption == '3':
                os.system("cls")
                print("Encrypting using the Vernam Cipher: \n")
                print("Enter the string you want to encrypt: ")
                input_string = input().strip()
                print("Enter the key you want to encrypt with: ")
                key_string = input().strip()
                if len(key_string) != len(input_string):
                    print("Enter the key with the same length as the input text ")
                else:
                    print(vernam_encrypt(input_string, key_string))



        elif choice == "2":
            input_string = input("Please enter the string to be decrypted: ")
            key = int(input("Please enter off-set: ").strip())

            print(decrypt(input_string, key))
        elif choice == "3":
            input_string = input("Please enter the string to be decrypted: ")
            brute_force_data = brute_force_with_frequency(input_string)

            for key, value in brute_force_data.items():
                print(f"Key: {key} | Message: {value}")
        elif choice == "4":
            input_string = input("Please enter the string to be decrypted: ")
            decrypted_text = brute_force_with_frequency(input_string)
            print(f"Decrypted text (most likely): {decrypted_text}")
        elif choice == "5":
            print("Goodbye.")
            break
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
if __name__=="__main__":
    text_path = "caesar_file.txt"
    key_path = "caesar_key.txt"

    text = CaesarCipher.read_text_from_file(text_path)
    key = int(CaesarCipher.read_key_from_file(key_path))

    vigenere_cipher = CaesarCipher(text)
    encrypted_text = vigenere_cipher.encrypt(text, key)

    decrypted_text = vigenere_cipher.decrypt(encrypted_text, key)
    print("The original text is: ", text)
    print("The key is: ", key)

    print("Encrypted Text:", encrypted_text)
    print("Decrypted Text:", decrypted_text)

    # GCYCZFMLYLEIM

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Usage example:
text_path = "text.txt"
key_path = "key.txt"

text = VernamCipher.read_text_from_file(text_path)
key = VernamCipher.read_key_from_file(key_path)

vernam_cipher = VernamCipher(text)
encrypted_text = vernam_cipher.vernam_encrypt(text,key)

decrypted_text = vernam_cipher.vernam_decrypt(encrypted_text,key)

print("Encrypted Text:", encrypted_text)
print("Decrypted Text:", decrypted_text)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import numpy as np
from PIL import Image

message = input("Enter the word you wanna encrypt: ")

# Encode the message in a serie of 8-bit values
b_message = ''.join(["{:08b}".format(ord(x)) for x in message])
b_message = [int(x) for x in b_message]

b_message_lenght = len(b_message)

# Get the image pixel arrays
with Image.open("img.png") as img:
    width, height = img.size
    data = np.array(img)

# Flatten the pixel arrays
data = np.reshape(data, -1)

# Overwrite pixel LSB
data[:b_message_lenght] = (data[:b_message_lenght] & ~1) | b_message

# Reshape back to an image pixel array
data = np.reshape(data, (height, width, 3))

new_img = Image.fromarray(data)
new_img.save("cover-secret.png")
new_img.show()

with Image.open("cover-secret.png") as img:
    width, height = img.size
    data = np.array(img)

data = np.reshape(data, width * height * 3)
# extract lsb
data = data & 1
# Packs binary-valued array into 8-bits array.
data = np.packbits(data)
# Read and convert integer to Unicode characters until hitting a non-printable character
# Read and convert integers to Unicode characters until reaching the end of the message
decoded_message = ""
for x in data:
    l = chr(x)
    if l == '\0':
        break
    decoded_message += l

print(decoded_message)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if __name__ == "__main__":
    image_steganography = ImageSteganography("img.png")

    message = input("Enter the word you want to encrypt: ")
    image_steganography.encode_message(message, "cover-secret.png")

    decoded_message = image_steganography.decode_message("cover-secret.png")
    print("Decoded Message:", decoded_message)


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 def create_gui_elements(self):
        # Label to choose the cipher
        cipher_label = tk.Label(self, text="Select Cipher:")
        cipher_label.pack()

        # Radio buttons to choose the cipher
        caesar_radio = tk.Radiobutton(self, text="Caesar Cipher", variable=self.selected_cipher, value="caesar")
        caesar_radio.pack()
        vigenere_radio = tk.Radiobutton(self, text="Vigenere Cipher", variable=self.selected_cipher, value="vigenere")
        vigenere_radio.pack()
        vernam_radio = tk.Radiobutton(self, text="Vernam Cipher", variable=self.selected_cipher, value="vernam")
        vernam_radio.pack()

        # Input field for text file path
        text_file_label = tk.Label(self, text="Text File Path:")
        text_file_label.pack()
        self.text_file_entry = tk.Entry(self)
        self.text_file_entry.pack()

        # Input field for key file path
        key_file_label = tk.Label(self, text="Key File Path:")
        key_file_label.pack()
        self.key_file_entry = tk.Entry(self)
        self.key_file_entry.pack()

        #
        encrypt_button = tk.Button(self, text="Encrypt", command=self.encrypt)
        encrypt_button.pack()
        result_label = tk.Label(self, text="Encrypted Text:")
        result_label.pack()
        self.result_text = tk.Text(self, height=10, width=40)
        self.result_text.pack()

    def encrypt(self):
        cipher_type = self.selected_cipher.get()
        text_file_path = self.text_file_entry.get()
        key_file_path = self.key_file_entry.get()

        if cipher_type == "caesar":
            cipher = caesar.CaesarCipher
        elif cipher_type == "vigenere":
            cipher = vigenere.VigenereCipher
        elif cipher_type == "vernam":
            cipher = vernam.VernamCipher
        else:
            # Handle invalid selection
            return

        with open(text_file_path, 'r') as text_file, open(key_file_path, 'r') as key_file:
            text = text_file.read()
            key = key_file.read()


        encrypted_text = cipher.encrypt(text, key)
        self.result_text.delete('1.0', tk.END)  # Clear the result text
        self.result_text.insert(tk.END, encrypted_text)

        # You can display or save the encrypted text as needed

if __name__ == "__main__":
    app = EncryptionApp()
    app.mainloop()
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////