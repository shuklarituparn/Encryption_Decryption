To get the MSB simply do the binary and with the number you want to get the MSB with a number in which the
all the MSB are set as 1

Num & 0xFFFF0000

To get the LSB simply do the binary and with the number you want to get the LSB with a number in which the
all the LSB are set as 1

Num & 0x0000FFFF

this will leave the LSB intact

data[:b_message_lenght] = (data[:b_message_lenght] & ~1) | b_message

//This taking the AND with the complement of A will make the LSB free and then taking the OR will fill the place

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import sys
import math
from os import path

import cv2
import numpy as np


BITS = 2   #using the bucket of two bits

HIGH_BITS = 256 - (1 << BITS) #clearing the least significant bits
LOW_BITS = (1 << BITS) - 1   #
BYTES_PER_BYTE = math.ceil(8 / BITS)
FLAG = '%'


def insert(img_path, msg):
    img = cv2.imread(img_path, cv2.IMREAD_ANYCOLOR)
    # Save origin shape to restore image
    ori_shape = img.shape
    print(ori_shape)
    max_bytes = ori_shape[0] * ori_shape[1] // BYTES_PER_BYTE
    # Encode message with length
    msg = '{}{}{}'.format(len(msg), FLAG, msg)
    assert max_bytes >= len(
        msg), "Message greater than capacity:{}".format(max_bytes)
    data = np.reshape(img, -1)
    for (idx, val) in enumerate(msg):
        encode(data[idx * BYTES_PER_BYTE: (idx + 1) * BYTES_PER_BYTE], val)

    img = np.reshape(data, ori_shape)
    filename, _ = path.splitext(img_path)
    filename += '_lsb_embeded' + ".png"
    cv2.imwrite(filename, img)
    return filename


def encode(block, data):
    # returns the Unicode code from a given character
    data = ord(data)
    for idx in range(len(block)):
        block[idx] &= HIGH_BITS
        block[idx] |= (data >> (BITS * idx)) & LOW_BITS

def decrypt():
    pass



if __name__ == '__main__':

    if len(sys.argv) == 3:
        img_path = sys.argv[1]
        msg = sys.argv[2]
    else:
        img_path = "img.jpg"
        msg = 'We got our man. Leave from the shipping port, gate B by Friday evening.'

    res_path = insert(img_path, msg)
    print("Successfully embedded.")






///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



message_to_code = 'hello'

# Encoding the text in the 8bit values

# Encoding the text in the 8bit values
b_message = ''.join(["{:08b}".format(ord(x)) for x in message_to_code])
b_message = [int(x, 2) for x in b_message]  # converting the ascii to the binary

b_message_length = len(b_message)

# opening the image
with Image.open('img.png') as img:
    width, height = img.size
    data = np.array(img)

# flattening the image into one single array

data = np.reshape(data, ( height, width, 3))

# encoding the data

# Encoding the data
for i in range(b_message_length):
    data[i % height, i % width, i % 3] = (data[i % height, i % width, i % 3] & ~1) | b_message[i]


# reshaping the file

data = np.reshape(data, (height,width,3))

new_image= Image.fromarray(data)
new_image.save(input("Enter the name of the output file")+'.png')
new_image.show()



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if __name__ == "__main__":
    input_string = input("Enter the string you want to encrypt: ")
    vig1 = VernamCipher(input_string)
    key_string = input("Enter the key string ")
    print(VernamCipher.vernam_decrypt(input_string, key_string))
#AABQROQUOK

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Usage example:
text_path = "vigenere_text.txt"
key_path = "vigenere_key.txt"

text = VigenereCipher.read_text_from_file(text_path)
key = VigenereCipher.read_key_from_file(key_path)

vigenere_cipher = VigenereCipher(text)
encrypted_text = vigenere_cipher.vigenere_encrypt(text, key)

decrypted_text = vigenere_cipher.vigenere_decrypt(encrypted_text, key)
print("The original text is: ", text)
print("The key is: ", key)

print("Encrypted Text:", encrypted_text)
print("Decrypted Text:", decrypted_text)

#GCYCZFMLYLEIM

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
if __name__ == "__main__":
    while True:
        print(f'\n{"-" * 10}\n Menu\n{"-" * 10}')
        print(*["1.Encrypt", "2.Decrypt", "3.Quit"], sep="\n")

        choice = input("\nWhat would you like to do?: ").strip() or "5"

        if choice not in ("1", "2", "3"):
            print("Invalid choice, please enter a valid choice")
        elif choice == "1":
            os.system('clear')
            print(f'\n{"-" * 10}\nChoose the Encryption Method:\n{"-" * 10}')
            print(*["1.Caesar", "2.Vigenere", "3.Vernam"], sep="\n")
            type_encryption = input().strip()
            if type_encryption not in ("1", "2", "3"):
                print("Invalid choice, please enter a valid choice")
            elif type_encryption == '1':
                os.system('clear')
                print("Encrypting using the Caesar Cipher: \n")
                print("Enter the string you want to encrypt: ")
                input_string = input().strip()
                key = int(input("Please enter off-set: ").strip())
                print(encrypt(input_string, key))

            elif type_encryption == '2':
                os.system("cls")
                print("Encrypting using the Vigenere Cipher: \n")
                print("Enter the string you want to encrypt: ")
                input_string = input().strip()
                print("Enter the key you want to encrypt with: ")
                key_string = input().strip()
                print(vigenere_encrypt(input_string, key_string))


            elif type_encryption == '3':
                os.system("cls")
                print("Encrypting using the Vernam Cipher: \n")
                print("Enter the string you want to encrypt: ")
                input_string = input().strip()
                print("Enter the key you want to encrypt with: ")
                key_string = input().strip()
                if len(key_string) != len(input_string):
                    print("Enter the key with the same length as the input text ")
                else:
                    print(vernam_encrypt(input_string, key_string))



        elif choice == "2":
            input_string = input("Please enter the string to be decrypted: ")
            key = int(input("Please enter off-set: ").strip())

            print(decrypt(input_string, key))
        elif choice == "3":
            input_string = input("Please enter the string to be decrypted: ")
            brute_force_data = brute_force_with_frequency(input_string)

            for key, value in brute_force_data.items():
                print(f"Key: {key} | Message: {value}")
        elif choice == "4":
            input_string = input("Please enter the string to be decrypted: ")
            decrypted_text = brute_force_with_frequency(input_string)
            print(f"Decrypted text (most likely): {decrypted_text}")
        elif choice == "5":
            print("Goodbye.")
            break
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
if __name__=="__main__":
    text_path = "caesar_file.txt"
    key_path = "caesar_key.txt"

    text = CaesarCipher.read_text_from_file(text_path)
    key = int(CaesarCipher.read_key_from_file(key_path))

    vigenere_cipher = CaesarCipher(text)
    encrypted_text = vigenere_cipher.encrypt(text, key)

    decrypted_text = vigenere_cipher.decrypt(encrypted_text, key)
    print("The original text is: ", text)
    print("The key is: ", key)

    print("Encrypted Text:", encrypted_text)
    print("Decrypted Text:", decrypted_text)

    # GCYCZFMLYLEIM

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Usage example:
text_path = "text.txt"
key_path = "key.txt"

text = VernamCipher.read_text_from_file(text_path)
key = VernamCipher.read_key_from_file(key_path)

vernam_cipher = VernamCipher(text)
encrypted_text = vernam_cipher.vernam_encrypt(text,key)

decrypted_text = vernam_cipher.vernam_decrypt(encrypted_text,key)

print("Encrypted Text:", encrypted_text)
print("Decrypted Text:", decrypted_text)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import numpy as np
from PIL import Image

message = input("Enter the word you wanna encrypt: ")

# Encode the message in a serie of 8-bit values
b_message = ''.join(["{:08b}".format(ord(x)) for x in message])
b_message = [int(x) for x in b_message]

b_message_lenght = len(b_message)

# Get the image pixel arrays
with Image.open("img.png") as img:
    width, height = img.size
    data = np.array(img)

# Flatten the pixel arrays
data = np.reshape(data, -1)

# Overwrite pixel LSB
data[:b_message_lenght] = (data[:b_message_lenght] & ~1) | b_message

# Reshape back to an image pixel array
data = np.reshape(data, (height, width, 3))

new_img = Image.fromarray(data)
new_img.save("cover-secret.png")
new_img.show()

with Image.open("cover-secret.png") as img:
    width, height = img.size
    data = np.array(img)

data = np.reshape(data, width * height * 3)
# extract lsb
data = data & 1
# Packs binary-valued array into 8-bits array.
data = np.packbits(data)
# Read and convert integer to Unicode characters until hitting a non-printable character
# Read and convert integers to Unicode characters until reaching the end of the message
decoded_message = ""
for x in data:
    l = chr(x)
    if l == '\0':
        break
    decoded_message += l

print(decoded_message)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

if __name__ == "__main__":
    image_steganography = ImageSteganography("img.png")

    message = input("Enter the word you want to encrypt: ")
    image_steganography.encode_message(message, "cover-secret.png")

    decoded_message = image_steganography.decode_message("cover-secret.png")
    print("Decoded Message:", decoded_message)


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 def create_gui_elements(self):
        # Label to choose the cipher
        cipher_label = tk.Label(self, text="Select Cipher:")
        cipher_label.pack()

        # Radio buttons to choose the cipher
        caesar_radio = tk.Radiobutton(self, text="Caesar Cipher", variable=self.selected_cipher, value="caesar")
        caesar_radio.pack()
        vigenere_radio = tk.Radiobutton(self, text="Vigenere Cipher", variable=self.selected_cipher, value="vigenere")
        vigenere_radio.pack()
        vernam_radio = tk.Radiobutton(self, text="Vernam Cipher", variable=self.selected_cipher, value="vernam")
        vernam_radio.pack()

        # Input field for text file path
        text_file_label = tk.Label(self, text="Text File Path:")
        text_file_label.pack()
        self.text_file_entry = tk.Entry(self)
        self.text_file_entry.pack()

        # Input field for key file path
        key_file_label = tk.Label(self, text="Key File Path:")
        key_file_label.pack()
        self.key_file_entry = tk.Entry(self)
        self.key_file_entry.pack()

        #
        encrypt_button = tk.Button(self, text="Encrypt", command=self.encrypt)
        encrypt_button.pack()
        result_label = tk.Label(self, text="Encrypted Text:")
        result_label.pack()
        self.result_text = tk.Text(self, height=10, width=40)
        self.result_text.pack()

    def encrypt(self):
        cipher_type = self.selected_cipher.get()
        text_file_path = self.text_file_entry.get()
        key_file_path = self.key_file_entry.get()

        if cipher_type == "caesar":
            cipher = caesar.CaesarCipher
        elif cipher_type == "vigenere":
            cipher = vigenere.VigenereCipher
        elif cipher_type == "vernam":
            cipher = vernam.VernamCipher
        else:
            # Handle invalid selection
            return

        with open(text_file_path, 'r') as text_file, open(key_file_path, 'r') as key_file:
            text = text_file.read()
            key = key_file.read()


        encrypted_text = cipher.encrypt(text, key)
        self.result_text.delete('1.0', tk.END)  # Clear the result text
        self.result_text.insert(tk.END, encrypted_text)

        # You can display or save the encrypted text as needed

if __name__ == "__main__":
    app = EncryptionApp()
    app.mainloop()
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



import tkinter as tk
from tkinter import messagebox
from tkinter import simpledialog
from PIL import Image
from Encrypt import (
    caesar_encrypt, vigenere_encrypt, vernam_encrypt,
    caesar_decrypt, vigenere_decrypt, vernam_decrypt
)
import os

class CipherApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Encryption/Decryption App")

        self.mode_label = tk.Label(root, text="Choose Mode:")
        self.mode_label.pack()

        self.mode_var = tk.StringVar(value="cipher")
        self.mode_menu = tk.OptionMenu(root, self.mode_var, "cipher", "steganography")
        self.mode_menu.pack()

        self.cipher_label = tk.Label(root, text="Choose Cipher:")
        self.cipher_label.pack()

        self.cipher_var = tk.StringVar(value="caesar")
        self.cipher_menu = tk.OptionMenu(root, self.cipher_var, "caesar", "vigenere", "vernam")
        self.cipher_menu.pack()

        self.operation_var = tk.StringVar(value="encrypt")
        self.operation_label = tk.Label(root, text="Choose Operation:")
        self.operation_label.pack()
        self.operation_menu = tk.OptionMenu(root, self.operation_var, "encrypt", "decrypt")
        self.operation_menu.pack()

        self.input_text_label = tk.Label(root, text="Input Text/Path:")
        self.input_text_label.pack()

        self.input_text_entry = tk.Entry(root)
        self.input_text_entry.pack()

        self.key_label = tk.Label(root, text="Key/Output Name:")
        self.key_label.pack()

        self.key_entry = tk.Entry(root)
        self.key_entry.pack()

        self.submit_button = tk.Button(root, text="Submit", command=self.handle_submit)
        self.submit_button.pack()

    def handle_submit(self):
        mode = self.mode_var.get()
        operation = self.operation_var.get()

        if mode == "steganography":
            self.steganography_action(operation)
        else:
            cipher = self.cipher_var.get()
            self.cipher_action(cipher, operation)

    def steganography_action(self, operation):
        if operation == "encrypt":
            self.steganography_encrypt()
        else:
            self.steganography_decrypt()

    def steganography_encrypt(self):
        input_text = self.input_text_entry.get()
        if not input_text:
            messagebox.showerror("Error", "Please provide input text.")
            return

        image_path = simpledialog.askstring("Input", "Enter the path to the image:")
        if not image_path:
            messagebox.showerror("Error", "Please provide the image path.")
            return

        new_image_name = simpledialog.askstring("Input", "Enter the name of the output image (with extension):")
        if not new_image_name:
            messagebox.showerror("Error", "Please provide the output image name.")
            return

        try:
            self.encode_text_in_image(image_path, input_text, new_image_name)
            messagebox.showinfo("Steganography Encryption Result", "Image steganography encryption complete.")
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred during steganography encryption: {e}")

    def steganography_decrypt(self):
        image_path = self.input_text_entry.get()
        if not image_path:
            messagebox.showerror("Error", "Please provide the image path.")
            return

        try:
            decoded_text = self.decode_text_from_image(image_path)
            messagebox.showinfo("Steganography Decryption Result", f"Decoded Text: {decoded_text}")
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred during steganography decryption: {e}")

    def encode_text_in_image(self, image_path, data, new_image_name):
        image = Image.open(image_path, 'r')
        new_image = image.copy()
        self.encode_data(new_image, data)
        new_image.save(new_image_name, "PNG")

    def decode_text_from_image(self, image_path):
        image = Image.open(image_path, 'r')
        return self.decode_data(image)

    def encode_data(self, new_image, data):
        width, height = new_image.size
        data_len = len(data)
        x, y = 0, 0

        for pixel in self.modify_pixels(new_image.getdata(), data):
            new_image.putpixel((x, y), pixel)
            if x == width - 1:
                x = 0
                y += 1
            else:
                x += 1

    def decode_data(self, image):
        data = ''
        iter_pixels = iter(image.getdata())

        while True:
            pixels = [value for value in iter_pixels.__next__()[:3] +
                      iter_pixels.__next__()[:3] +
                      iter_pixels.__next__()[:3]]
            bin_str = ''

            for i in pixels[:8]:
                if i % 2 == 0:
                    bin_str += '0'
                else:
                    bin_str += '1'

            data += chr(int(bin_str, 2))
            if pixels[-1] % 2 != 0:
                return data

    def modify_pixels(self, pix, data):
        datalist = self.generate_data(data)
        lendata = len(datalist)
        imdata = iter(pix)

        for i in range(lendata):
            pixel = [value for value in imdata.__next__()[:3] +
                      imdata.__next__()[:3] +
                      imdata.__next__()[:3]]

            for j in range(8):
                if datalist[i][j] == '0' and pixel[j] % 2 != 0:
                    pixel[j] -= 1
                elif datalist[i][j] == '1' and pixel[j] % 2 == 0:
                    if pixel[j] != 0:
                        pixel[j] -= 1
                    else:
                        pixel[j] += 1

            if i == lendata - 1:
                if pixel[-1] % 2 == 0:
                    if pixel[-1] != 0:
                        pixel[-1] -= 1
                    else:
                        pixel[-1] += 1
            else:
                if pixel[-1] % 2 != 0:
                    pixel[-1] -= 1

            pixel = tuple(pixel)
            yield pixel[0:3]
            yield pixel[3:6]
            yield pixel[6:9]

    def generate_data(self, data):
        new_data = [format(ord(char), '08b') for char in data]
        return new_data

    def cipher_action(self, cipher, operation):
        input_text = self.input_text_entry.get()
        key = self.key_entry.get()

        if not input_text:
            messagebox.showerror("Error", "Please provide input text.")
            return

        try:
            if operation == "encrypt":
                result = self.encrypt_text(cipher, input_text, key)
            else:
                result = self.decrypt_text(cipher, input_text, key)

            if result is not None:
                messagebox.showinfo(f"{cipher.capitalize()} {operation.capitalize()} Result", result)
            else:
                messagebox.showerror("Error", "Decryption function not implemented for this mode.")
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

    def encrypt_text(self, cipher, input_text, key):
        if cipher == "caesar":
            return caesar_encrypt(input_text, int(key))
        elif cipher == "vigenere":
            return vigenere_encrypt(input_text, key)
        elif cipher == "vernam":
            return vernam_encrypt(input_text, key)
        else:
            return None  # Implement encryption function for other ciphers

    def decrypt_text(self, cipher, input_text, key):
        if cipher == "caesar":
            return caesar_decrypt(input_text, int(key))
        elif cipher == "vigenere":
            return vigenere_decrypt(input_text, key)
        elif cipher == "vernam":
            return vernam_decrypt(input_text, key)
        else:
            return None  # Implement decryption function for other ciphers

if __name__ == "__main__":
    root = tk.Tk()
    app = CipherApp(root)
    root.mainloop()


